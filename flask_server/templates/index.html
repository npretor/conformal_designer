<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>CircuitPainter</title>
    </head>
    <body  style="margin:0;padding:0;"> 
        <script type="importmap">
            { 
                "imports": { 
                    "three": "../static/js/node_modules/three/build/three.module.js" 
                } 
            } 
        </script> 

        <script type="module">
            import * as THREE from 'three';
            import Stats from '../static/js/node_modules/three/examples/jsm/libs/stats.module.js';
            import { GUI } from '../static/js/node_modules/three/examples/jsm/libs/lil-gui.module.min.js';
            import { OrbitControls } from '../static/js/node_modules/three/examples/jsm/controls/OrbitControls.js';
            import { GLTFLoader } from '../static/js/node_modules/three/examples/jsm/loaders/GLTFLoader.js';
            import { STLLoader } from '../static/js/node_modules/three/examples/jsm/loaders/STLLoader.js';
            import { DecalGeometry } from '../static/js/node_modules/three/examples/jsm/geometries/DecalGeometry.js';

            // Variables 
            let renderer, scene, camera, stats; 
            let mesh;
			let raycaster;
			let line;
            let mouseHelper;
            const decals = [];

			const intersection = {
				intersects: false,
				point: new THREE.Vector3(),
				normal: new THREE.Vector3()
			};          
			const mouse = new THREE.Vector2();
			const intersects = [];

            // Groups: Components, traces, ratnest  
            const component_group = new THREE.Group();  
            const component_list = [];           

            const pointer_position = new THREE.Vector3(); 
            const orientation = new THREE.Euler(); 
            const size = new THREE.Vector3( 10, 10, 10 );
            const container = document.getElementById( 'container' ); 


            // Initialize on loading 
            window.addEventListener( 'load', init ); 

            function init(){

                // Just for the basics, make a renderer, scene, camera, controls and some lights 

                // Renderer 
                renderer = new THREE.WebGLRenderer( { antialias: true } ); 
                renderer.setPixelRatio( window.devicePixelRatio ); 
                renderer.setSize( window.innerWidth, window.innerHeight ); 
                container.appendChild( renderer.domElement ); 

                // Scene 
                scene = new THREE.Scene();
                scene.add( component_group );  
                

                // Camera 
                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.x = 100;
                camera.position.y = 100;
                camera.position.z = 100;

                // Controls 
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.minDistance = 5;
                controls.maxDistance = 2000;            

                // Lights 
                scene.add( new THREE.AmbientLight( 0x443333 ) );
                const dirLight1 = new THREE.DirectionalLight( 0xffddcc, 1 );
                dirLight1.position.set( 100, 0.75, 0.5 );
                scene.add( dirLight1 );
                const dirLight2 = new THREE.DirectionalLight( 0xccccff, 1 );
                dirLight2.position.set( - 100, 0.75, - 0.5 );
                scene.add( dirLight2 );

                // Raycaster for intersections 
                raycaster = new THREE.Raycaster();

                // Mouse helper 
                mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
                mouseHelper.visible = false;
                scene.add( mouseHelper );

                // Simple test geometry 
                // let simple_box; 
                // simple_box = new THREE.Mesh(new THREE.BoxGeometry(10,10, 10), new THREE.MeshNormalMaterial());
                // scene.add( simple_box );

                // Coordinate origin 
                function createOrigin(){ 
                    const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); 
                    const origin_points = []; 
                    origin_points.push( new THREE.Vector3(  10,  0,  0 ) ); 
                    origin_points.push( new THREE.Vector3(   0, 10,  0 ) ); 
                    origin_points.push( new THREE.Vector3(   0,  0, 10 ) ); 
                    const geometry = new THREE.BufferGeometry().setFromPoints( origin_points ); 
                    const origin_lines = new THREE.Line( geometry, material );  
                    //origin_lines.width.set(3) 
                    scene.add( origin_lines ); 
                }
                createOrigin();


				const geometry = new THREE.BufferGeometry();
				geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );

                // Line used for the normal pointer
                line = new THREE.Line( geometry, new THREE.LineBasicMaterial() );
				scene.add( line );

                loadPrimaryGeometry();
                
                // Check for if we are interecting 
                window.addEventListener( 'resize', onWindowResize );

                let moved = false;
                controls.addEventListener( 'change', function () {
                    moved = true;
                });

                window.addEventListener( 'pointerdown', function () {
                    moved = false; 
                }); 

                window.addEventListener( 'pointerup', function ( event ) {
                    if ( moved === false ) {
                        checkIntersection( event.clientX, event.clientY );
                        if ( intersection.intersects ) shoot();
                    }
                }); 

                window.addEventListener( 'pointermove', onPointerMove );
                function onPointerMove( event ) {
                    if ( event.isPrimary ) {
                        checkIntersection( event.clientX, event.clientY );
                    }
                }            

                function checkIntersection( x, y ) {

                    if ( mesh === undefined ) return;

                    mouse.x = ( x / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( y / window.innerHeight ) * 2 + 1;

                    raycaster.setFromCamera( mouse, camera );
                    raycaster.intersectObject( mesh, false, intersects );

                    if ( intersects.length > 0 ) {
                        const p = intersects[ 0 ].point;
                        mouseHelper.position.copy( p );
                        intersection.point.copy( p );

                        const n = intersects[ 0 ].face.normal.clone();
                        n.transformDirection( mesh.matrixWorld );
                        n.multiplyScalar( 10 );
                        n.add( intersects[ 0 ].point );

                        intersection.normal.copy( intersects[ 0 ].face.normal );
                        mouseHelper.lookAt( n );

                        const positions = line.geometry.attributes.position;
                        positions.setXYZ( 0, p.x, p.y, p.z );
                        positions.setXYZ( 1, n.x, n.y, n.z );
                        positions.needsUpdate = true;

                        intersection.intersects = true;
                        intersects.length = 0;

                    } else {
                        intersection.intersects = false;
                    }
                }            

                onWindowResize();
                animate();

            }; 

            function loadPrimaryGeometry(){
                const material= new THREE.MeshNormalMaterial() 
                // const material = new THREE.MeshPhysicalMaterial({ color: 0xaaaaaa })
                const loader = new STLLoader();

                loader.load('../static/models/wing/wing.stl', function (mesh_geometry){
                    mesh = new THREE.Mesh(mesh_geometry, material);
                    component_group.add(mesh);
                    scene.add(mesh);
                    mesh.scale.set( 1, 1, 1 );
                });
            }

			function shoot() {

                pointer_position.copy( intersection.point );
                orientation.copy( mouseHelper.rotation );

                const sphere_geometry   = new THREE.SphereGeometry( 1, 32, 16 ); 
                const sphere_material   = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
                const sphere            = new THREE.Mesh( sphere_geometry, sphere_material); 

                const m = new THREE.Mesh(sphere_geometry, sphere_material);
                m.position.set(pointer_position.x, pointer_position.y, pointer_position.z);

                component_group.add(m); 
                component_list.push(m);
                saveCurrentGeometry()
            } 


            
            function saveCurrentGeometry(){
                // Save the primary mesh
                // Save each item's id and location 

                // POST to 
                fetch('/save_components',{
                    method:'post',
                    headers:{
                        "Accept": "application/json, text/plain, */*",
                        "Content-type": "application/json; charset = UTF-8"
                    },   
                    body: JSON.stringify(component_list)
                })
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
                }
            
            function animate(){
                requestAnimationFrame( animate )
                renderer.render( scene, camera )
                //stats.update();
            }; 

        </script>

        <div id="container">

        </div>


    </body>
</html>